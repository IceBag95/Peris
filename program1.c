#include <stdio.h>
#include <math.h>

int main() {

    int x;
    
    printf("How many prime numbers to calculate? ");

    // Ελεγχος εγκυρότητας για x > 0
    do {
        printf("\nΠαρακαλώ εισάγετε θετικό αριθμό: ");
        scanf("%d", &x);
    } while ( x <= 0 );

    // θέτω ένα counter για να μπορώ να μετράω πόσους πρώτους βρίσκω.
    // Ξεκινάω από το 1 γιατί αναγκαστικά αν είναι θετικός θα ψάχνει τουλάχιστον έναν ακέραιο
    int counter = 1;
    int i = 2;  // αυτό μου δείχνει ποιον αριθμό ελέγχω αν είναι πρώτος. Ξεκινάω από το 2 γιατί είναι ο πρώτος "πρώτος".
    while (counter <= x) {
        int is_prime = 1;

        for (int j = 2; j <= sqrt(i); j++){ // το j μου διαλέγει αριθμούς πριν το i βλέπε εξήγηση παρακάτω **
            // ελέγχω αν τυχόν δεν είναι πρώτος
            if (i % j == 0) {
                is_prime = 0;
            }
        
        }

        // αν πραγματι δεν είναι πρώτος το εμφανίζω (αλλιώς δεν κάνω τίποτα - skip)
        if (is_prime == 1) {
            printf("\nPrime #%d: %d",counter, i);
            counter++;
        }

        i++; // παίρνω για έλεχγο τον επόμενο αριθμό και ξανά η επανάληψη απο την αρχή.
    }

    return 0;
}



/*
** Επεξήγηση:

    - Το i παίρνει διαδοχικά σε κάθε επανάληψη αριθμούς, ξεκινώντας από τον αριθμό 2
    - Το θέμα είναι τι γίνεται σε κάθε επανάληψη? θ ατο πάμε με παράδειγμα:
    - Έστω οτι φτάνω σε μια επανάληψη που ελέγχεται το 11 αν είναι πρώτος
    - Για να είναι το 11 πρώτος δεν πρέπει να διαιρείται με κανέναν προηγούμενο αριθμό (καλή ιδεά αλλά μπορόυμε να την κάνουμε καλύτερη). Άρα έχουμε πίσω από το 11 του αριθμούς: 1, 2, 3, 4, 5,6,7, 8, 9, 10. 
    - Επειδή όσο μεγαλύτερος είναι ο αριθμός τόσο περισσότερους αριθμούς πρέπει να ελέγξω αν τον διαιρουν (πχ για 5 είναι 3 οι αρθμοί που ελέγχω 2,3,4 αλλά για 100 είναι 2,3,4,5.....,98,99. Ειναι πολλοί οι αριθμοί)
    - Η άσκηση λοιπόν σε σώζει λέγοντας σου μην του ελέγξεις όλους τους προηγούμενους. Αρκεί να ελέγξεις όλους όσους είναι μικρότεροι της τετραγωνικής ρίζας του αριθμού.
    - Αν κανενας δεν τον διαιρεί μέχρι την τετραγωνική ρίζα τότε σίγουρα είναι πρώτος. Με αυτή τη λογική πάμε να κάνουμε τα εξής:
    - Παίρνω το j το οποίο ξεκινάει απο το 2 πάντα. Αυτό μου παίρνει όλους τους αριθμούς πίσω από την τετραγωνική ρίζα του 11 (εδώ είναι περίπου το 3.5)
    - Στην πρώτη επανάληψη για το j λέω είναι το 2 (από το οποίο ξεκινάω) μικρότερο του 3.5 (τετραγωνική ρίζα του 11)? Ναι. Διαιρεί το 2 ακριβώς το 11? Όχι. (καλο αυτο)
    - Άρα αυξάνω το j κατά 1 και πλέον είναι 3.
    - Στην δεύτερη επανάληψη κανω το ίδιο για το 3 και έχω τα ίδια αποτελέσματα. Ουτε με το 3 διαιρείται
    - Πάμε για το 4. το 4 είναι μικρότερο του 3.5? ΟΧΙ! ΤΕΛΟΣ Η ΕΠΑΝΑΛΗΨΗ ΔΕΝ ΕΛΕΓΧΩ ΑΛΛΟΥΣ ΑΡΙΘΜΟΥΣ!
    - Και τώρα η βασική ερώτηση: Βρήκαμε προηγούμενο αριθμό να διαιρεί ακριβώς το 11? ΟΧΙ!
    - Άρα το 11 είναι πρώτος αριθμός. Τον εμφανίζω και αυξάνω τον μετρητή counter κατά ένα (γιατί βρήκα άλλον έναν αριθμό που είναι πρώτος)
    - Το x δείχνει πόσους πρώτους αριθμούς ζήτησε να του βρούμε ο χρήστης (τό εβαλε ο ίδιος στην αρχή του προγράμματος). 

    Αυτή τη λογική την επαναλαμβάνουμε μέχρι το counter να φτάσει να είναι όσο το x. 

*/